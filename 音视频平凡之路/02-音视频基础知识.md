# 第二章 音视频基础知识
## 1.概要
俗话说：万丈高楼平地起，再难的事情都要从打基础开始，学习音视频一个漫长的过程，其中有些点可能很难，那是因为我们没有打好基础，基础牢靠了，学习自然能得心应手。好了，废话少说，我们从最基础的编译介绍，其次介绍Android jni相关知识，然后Android原生的音视频相关的api，然后介绍一些好的开源项目。开源项目的知识比较多，，本章只是介绍，不会过多涉及开源项目的原理，当然后面会着重介绍这些开源项目的。

## 2.交叉编译
交叉编译是什么？对于没有做过嵌入式开发的人来说，也许很陌生，一些Android的开发，如果没有过多涉及jni方面，也不太清楚什么是交叉编译，通俗来讲，交叉编译就是在一个平台上生成另外一个平台可以执行的代码。例如Windows上可执行的文件是.exe，但是.exe文件是不能在Android上面运行的，我如果想编译一个库文件，让这个库文件在Android平台上被加载，那这个编译的过程就是交叉编译。
交叉编译在音视频开发者真的这么重要吗？可以明确的说，非常重要，因为音视频的核心开发逻辑都在native层，java层只是一个接口api和简单的封装，所以jni和native交互不可避免，而且音视频中大量用到一些流行的库，例如ffmpeg、ijkplayer、vlc、fdk-aac、libx264、librtmp等等，这些库想要生成Android平台上可以加载的库，就需要交叉编译。关于这些库怎么交叉编译的，本章的后面会讲到。
### 2.1 交叉编译工具
做过jni项目的都知道jni代码是使用ndk编译的，ndk中就包含交叉编译工具链，在什么地方了，下面看一下ndk的目录结构：<br>
![ndk目录结构](./02-files/01.png)<br>
我们所说的交叉编译工具链就在这个toolchains文件夹中，可以深入进去看一下：<br>
![toolchains目录结构](./02-files/02.png)<br>
> * aarch64-linux-android-4.9
> * arm-linux-androideabi-4.9
> * mipsel-linux-android-4.9
> * mips64el-linux-android-4.9
> * x86-4.9
> * x86_64-4.9

这其实是针对不同的CPU架构平台，我们熟知的是arm平台，Android手机基本上都是基于arm平台的，x86主要是PC，mips架构是Microprocessor without interlocked piped stages architecture的缩写，是一种采用精简指令集的处理器架构，主要用在一些个人娱乐装置上，它们三个指令集各有优劣。
<br>
**ARM**<br>
ARM全程是Advanced RISC Machine，它是一个精简的指令集，ARM处理器的特点是：
> * 体积小，低功耗，低成本，高性能，目前ARM也是嵌入式设备中使用最广泛的芯片架构
> * 大量使用到了寄存器，指令执行速度更快，它的大多数数据操作都在寄存器中执行
> * 寻址方式灵活简单，执行效率高
> * 指令长度固定
> * 流水线的处理方式

**X86**<br>
X86是intel主导设计的一个微处理器体系结构的指令架构，PC端主要称霸的是X86架构，与ARM不同，X86采用的是CISC架构，就是复杂指令集计算机，CISC与RISC不同，程序中指令是按照顺序串行执行的，每条指令中的操作也是顺序串行的。

顺序执行优点是控制比较简单，但是利用效率较低，执行速度也不太快。

**MIPS**<br>
MIPS是采用RISC指令集的架构，全称是Microprocessor without interlocked piped stages architecture，由MIPS推出，其基本特点是：
> * 包含大量的寄存器、指令集和字符
> * 可视化的管道延时处理
> * 能耗非常想小。

但是很可惜，最近听说MIPS已经开始拥抱ARM了，市场上的选择变少了，不得不说是一种悲哀。


介绍完了不同架构的区别，现在可以看看有什么具体的交叉编译工具，可以选择arm平台进去看看：<br>
![交叉编译工具](./02-files/03.png)<br>
我们介绍几个常用的吧。
> * arm-linux-androideabi-gcc : 编译c文件的交叉编译器，和gcc类似，不同的是arm-linux-androideabi-gcc的头文件是/urs/include/stdio.h，下面编译能看出来，我们要定义sysroot来链接到头文件。
> * arm-linux-androideabi-g++ : 编译cpp文件的交叉编译器
> * arm-linux-androideabi-addr2line : 反解出堆栈的工具，Android上的Native Crash堆栈都是通过addr2line反解出来的
> * arm-linux-androideabi-ld : 交叉链接器，可以将编译出来的文件链接成在arm平台上运行的文件
> * arm-linux-androideabi-readelf : 查看.elf文件的工具，编译程序运行不了的原因主要看处理器的大小端跟编译的程序的大小端是否对应，可以使用这个工具来查看一下。
> * arm-linux-androideabi-objdump : 将可执行文件反汇编后输入保存到文本中，可以查看底层的汇编代码。
> * arm-linux-androideabi-ar : 可以将多个重定位的目标模块归档为一个函数库文件。

交叉编译有一个完整的过程：<br>
![交叉编译流程](./02-files/10.png)<br>


下面我们运行一个简单的例子来加深对交叉编译工具的理解：
一个很简单的c程序
```
#include <stdio.h>

int main(int argc, char** argv) {
	printf("Hello, jeffmony\n");
	return 0;
}
```
输出的结果如下：
```
jeffli@admindeMacBook-Pro 02-files % gcc hello.c -o hello
jeffli@admindeMacBook-Pro 02-files % ./hello 
Hello, jeffmony
```

gcc编译出来的可执行文件只能在当前架构的平台上执行，如果我想在Android上执行这个程序就需要使用arm-linux-androideabi-gcc来编译hello.c，编译代码如下：
```
$ANDROID_NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-gcc \
--sysroot=$ANDROID_NDK/platforms/android-24/arch-arm hello.c -o hello-android
```
这个--sysroot表示链接的头文件的地址，如下图：<br>
![sysroot地址](./02-files/04.png)<br>
里面放着include和lib文件夹，分别表示Android平台下的头文件的库文件，我们编译的任何文件都可能会引用到这个文件架下面的库。这个链接是不能少的。
编译出来的hello-android是可以在Android手机上运行的。

### 2.2 CMake
大家在Android5.0用过ndk编译的话，当时是使用ndk-build工具进行编译的，还需要配置Android.mk和Application.mk。
当然现在肯定不需要了，CMake会自动帮你生成的，你只需要按照对应的格式，填写CMakeLists.txt文件就行了。按照特定的语法。
我们先来介绍一下什么是CMake？
CMake 是一个开源、跨平台的工具系列，旨在构建、测试和打包软件。CMake用于使用简单的平台和编译器独立配置文件来控制软件编译过程，并生成可在您选择的编译器环境中使用的本机 makefile 和工作区。 CMake 工具套件由 Kitware 创建，以响应对 ITK 和 VTK 等开源项目的强大跨平台构建环境的需求。

Cmake其实是一套项目整理的工具，可以整合完整的编译流程，Android也引入了这套机制，非常好用。
创建一个包含native代码的工程，主要关注这两个结构:<br>
![native工程结构](./02-files/11.png)<br>
main目录下创建了cpp和java文件夹，cpp就是写native代码的，java就是上层代码，其中cpp文件夹下面有一个CMakeLists.txt文件，这个文件就是组织cpp文件的一个工具。
下面看一个CMakeLists.txt的例子：
```
# Sets the minimum version of CMake required to build the native
# library.
cmake_minimum_required(VERSION 3.4.1)

# Creates the project's shared lib: libnative-lib.so.
# The lib is loaded by this project's Java code in MainActivity.java:
#     System.loadLibrary("native-lib");
# The lib name in both places must match.
add_library( native-lib
             SHARED
             src/main/cpp/native-lib.cpp )

find_library(log-lib
             log )

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in the
# build script, prebuilt third-party libraries, or system libraries.

target_link_libraries( # Specifies the target library.
                       native-lib

                       # Links the target library to the log library
                       # included in the NDK.
                       ${log-lib} )

```
add_library里面包括我们cpp中所有的native代码，部分头文件可以不用附上，native-lib是我们目标库的名称，编译出来的目标库是libnative-lib.so，target_link_libraries后面参数说明编译出libnative-lib.so需要链接那些系统库。

这儿这是简单介绍一下，后面的实战部分会更加详细的介绍。

build.gradle就是将CMakeLists.txt组织到项目中的核心枢纽。
```
// Sets up parameters for both jni build and cmake.
// For a complete list of parameters, see
// developer.android.com/ndk/guides/cmake.html#variables
externalNativeBuild {
   cmake {
       // cppFlags are configured according to your selection
       // of "Customize C++ Support", in this codelab's
       //    "Create a Sample App with the C++ Template",
       //    step 6
       cppFlags "-std=c++17"
   }
......

// Specifies the location of the top level CMakeLists.txt
// The path is relative to the hosting directory
// of this build.gradle file
externalNativeBuild {
   cmake {
       path "src/main/cpp/CMakeLists.txt"
       version "3.10.2"

   }
}

```
CMakeLists.txt文件可以放在任意位置，只要在build.gradle特殊指定就行了。
同时别忘了在Java层System.loadLibrary这个库。
我们编译完成后，在build目录中会生成对应的so


**独立工具链**
现在已经很少谈到独立工具链了，但是对于一些大型的项目，独立工具链还是有它独特的优势的，因为独立工具链真的很灵活。
NDK提供了make_standalone_toolchain.py 脚本，以便您通过命令行执行自定义工具链安装。脚本位于 $ANDROID_NDK/build/tools/目录中：<br>
![独立工具链](./02-files/12.png)<br>
创建独立工具链：
```
$ANDROID_NDK/build/tools/make_standalone_toolchain.py \
    --arch arm --api 21 --install-dir /tmp/my-android-toolchain

```
此命令创建一个名为 /tmp/my-android-toolchain/ 的目录，其中包含 android-21/arch-arm sysroot 的副本，以及适用于 32 位 ARM 目标的工具链二进制文件的副本。

请注意，工具链二进制文件不依赖或包含主机专属路径。换言之，您可以将其安装在任意位置，甚至可以视需要改变其位置。

**为什么特别提到了独立工具链了？**
因为我们熟知的很多大型项目，例如ijkplayer，使用的就是独立工具链，控制非常灵活，建议大家在编译类似项目的时候，也是用独立工具链。

### 2.3 大型项目的交叉编译
接触音视频工程，不得不提到的就是ffmpeg，基本上音视频入门的交叉编译就是编译生成ffmpeg库，下面通过讲解ffmpeg的完整交叉编译过程来帮忙大家理解一下交叉编译的过程。
我们在音视频开发中，编译FFmpeg，需要包括openssl、fdk-aac、libx264，怎么实现了？
推荐一个开源项目：https://github.com/JeffMony/JianYing/tree/main/av_tools<br>
![ffmpeg开源项目](./02-files/13.png)<br>
![编译脚本](./02-files/14.png)<br>
> * 配置NDK地址，直接配置到环境变量中，ANDROID_NDK=XXX
> * 下载ffmpeg代码，执行init_ffmpeg.sh代码
> * 下载openssl代码，执行init_openssl.sh
> * 下载fdk-aac代码，执行init_fdkaac.sh
> * 下载libx264代码，执行init_libx264.sh
> * 进入sources，首先执行./compile_openssl.sh，编译openssl代码
> * 编译fdk-aac，执行./compile_fdkaac.sh
> * 编译libx264，执行./compile_libx264.sh
> * 编译ffmpeg，执行./compile_ffmpeg.sh

因为ffmpeg中需要链接openssl、libfdk-aac、libx264，具体的编译脚本如下，大家可以参考下
```
#!/bin/bash


# compile ffmpeg

export NDK_ROOT=${ANDROID_NDK}

CUR_DIR=$(pwd)

BUILD_DIR=${CUR_DIR}/build

PREFIX=${BUILD_DIR}/ffmpeg

FFMPEG_SOURCE_DIR=${CUR_DIR}/ffmpeg

ARCH_PREFIX=

API=24

ARCH=$1

PLATFORM=

HOST=

COMPILE_PLATFORM=

SYSROOT=

CROSS_PREFIX=

OPENSSL_LIB_DIR=

LIBX264_LIB_DIR=

FDKAAC_LIB_DIR=

EXTRA_OPTIONS=

EXTRA_CFLAGS=

EXTRA_LDFLAGS=

cd ${FFMPEG_SOURCE_DIR}


clean() {
	rm -rf ${PREFIX} 
}

build() {
	ARCH=$1
	echo "开始编译 ${ARCH} so"

	PLATFORM=$2

	if [ "${ARCH}" == "arm" ];
	then
		HOST=arm-linux
    	COMPILE_PLATFORM=$PLATFORM
	elif [ "${ARCH}" == "arm64" ];
	then
		HOST=aarch64-linux
    	COMPILE_PLATFORM=$PLATFORM
	elif [ "${ARCH}" == "x86" ];
	then
		HOST=i686-linux
    	COMPILE_PLATFORM=i686-linux-android	
	elif [ "${ARCH}" == "x86_64" ];
	then
		HOST=x86_64-linux
    	COMPILE_PLATFORM=x86_64-linux-android
	fi
	
	ARCH_PREFIX=${PREFIX}/${ARCH}
	rm -rf ${ARCH_PREFIX}
	
	SYSROOT=${NDK_ROOT}/platforms/android-${API}/arch-${ARCH}/
    CROSS_PREFIX=${NDK_ROOT}/toolchains/${PLATFORM}-4.9/prebuilt/darwin-x86_64/bin/${COMPILE_PLATFORM}-

    
    # 判断是否存在openssl
    OPENSSL_LIB_DIR=${BUILD_DIR}/openssl/${ARCH}
    if [ -f "${OPENSSL_LIB_DIR}/lib/libssl.a" ]; then
    	echo "OpenSSL detected"
    	EXTRA_OPTIONS="${EXTRA_OPTIONS} --enable-nonfree"
    	EXTRA_OPTIONS="${EXTRA_OPTIONS} --enable-openssl"
    	EXTRA_CFLAGS="${EXTRA_CFLAGS} -I${OPENSSL_LIB_DIR}/include"
    	EXTRA_LDFLAGS="${EXTRA_LDFLAGS} -L${OPENSSL_LIB_DIR}/lib -lssl -lcrypto"
    fi

    # 判断是否存在libx264
	LIBX264_LIB_DIR=${BUILD_DIR}/libx264/${ARCH}
	if [ -f "${LIBX264_LIB_DIR}/lib/libx264.a" ]; then
		echo "libx264 detected"
		EXTRA_OPTIONS="${EXTRA_OPTIONS} --enable-libx264"
		EXTRA_OPTIONS="${EXTRA_OPTIONS} --enable-encoder=libx264"
		EXTRA_CFLAGS="${EXTRA_CFLAGS} -I${LIBX264_LIB_DIR}/include"
    	EXTRA_LDFLAGS="${EXTRA_LDFLAGS} -L${LIBX264_LIB_DIR}/lib -lx264"
    fi

    # 判断是否存在 fdk-aac
    FDKAAC_LIB_DIR=${BUILD_DIR}/fdk-aac/${ARCH}
	if [ -f "${FDKAAC_LIB_DIR}/lib/libfdk-aac.a" ]; then
		echo "libfdk-aac detected"
		EXTRA_OPTIONS="${EXTRA_OPTIONS} --enable-nonfree"
		EXTRA_OPTIONS="${EXTRA_OPTIONS} --enable-libfdk-aac"
		EXTRA_OPTIONS="${EXTRA_OPTIONS} --enable-encoder=libfdk_aac"
		EXTRA_OPTIONS="${EXTRA_OPTIONS} --enable-muxer=adts"
		EXTRA_CFLAGS="${EXTRA_CFLAGS} -I${FDKAAC_LIB_DIR}/include"
    	EXTRA_LDFLAGS="${EXTRA_LDFLAGS} -L${FDKAAC_LIB_DIR}/lib -lfdk-aac -lm"
    fi

	./configure \
	--prefix=${ARCH_PREFIX} \
	--disable-doc \
	--enable-shared \
	--disable-static \
	--disable-x86asm \
	--disable-asm \
	--disable-symver \
	--disable-devices \
	--disable-avdevice \
	--enable-gpl \
	--disable-ffmpeg \
	--disable-ffplay \
	--disable-ffprobe \
	--enable-small \
	${EXTRA_OPTIONS} \
	--enable-cross-compile \
	--cross-prefix=${CROSS_PREFIX} \
	--target-os=android \
	--arch=${ARCH} \
	--sysroot=${SYSROOT} \
	--extra-cflags="${EXTRA_CFLAGS} -fPIE -pie" \
	--extra-ldflags="${EXTRA_LDFLAGS}"

    make clean
    make -j4
    make install
    echo "完成编译 ${ARCH} so"
}

case "${ARCH}" in
	"")
        build arm arm-linux-androideabi
    ;;
    arm)
        build arm arm-linux-androideabi
    ;;
    arm64)
        build arm64 aarch64-linux-android
    ;;
    x86)
        build x86 x86
    ;;
    x86_64)
        build x86_64 x86_64
    ;;
    all)
        build arm arm-linux-androideabi
        build arm64 aarch64-linux-android
        build x86 x86
        build x86_64 x86_64
    ;;
    clean)
         clean
    ;;
esac


cd -

```

## 3.JNI全面剖析
JNI是我们接触音视频开发首先要了解的一部分知识，所以我会由浅入深地给大家分析一下JNI相关的知识，帮忙大家了解JNI的具体知识。
JNI是全程是Java native interface
### 3.1 什么是静态和动态注册

### 3.2 JNI中的基本变量
### 3.3 JNI中的引用
### 3.4 JNI中如何实现多线程
### 3.5 完整的JNI多线程问题的调查分析流程
音视频开发中，会遇到很多Native Crash问题，下面介绍一种非常常见的JNI异常问题，具体堆栈如下：
```
#00 pc 0000000000089908 /apex/com.android.runtime/lib64/bionic/libc.so (abort+168)
#01 pc 0000000000552abc /apex/com.android.art/lib64/libart.so (_ZN3art7Runtime5AbortEPKc+2260)
#02 pc 0000000000013990 /system/lib64/libbase.so (_ZZN7android4base10SetAborterEONSt3__18functionIFvPKcEEEEN3$_38__invokeES4_+76)
#03 pc 0000000000012fb4 /system/lib64/libbase.so (_ZN7android4base10LogMessageD1Ev+320)
#04 pc 00000000002f8044 /apex/com.android.art/lib64/libart.so (_ZN3art22IndirectReferenceTable17AbortIfNoCheckJNIERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE+224)
#05 pc 0000000000389d70 /apex/com.android.art/lib64/libart.so (_ZNK3art22IndirectReferenceTable10GetCheckedEPv+444)
#06 pc 0000000000385324 /apex/com.android.art/lib64/libart.so (_ZN3art9JavaVMExt12DecodeGlobalEPv+24)
#07 pc 00000000005a6f68 /apex/com.android.art/lib64/libart.so (_ZNK3art6Thread13DecodeJObjectEP8_jobject+144)
#08 pc 000000000039ac7c /apex/com.android.art/lib64/libart.so (_ZN3art3JNIILb0EE14GetObjectClassEP7_JNIEnvP8_jobject+612)
#09 pc 00000000000d7a74 /data/app/~~yvshfyvSUZ46EK1lhAhiTQ==/com.shizhuang.duapp-aLxfQNnnePl3Xieaq6E1uQ==/lib/arm64/libav_media.so
#10 pc 00000000000ed098 /data/app/~~yvshfyvSUZ46EK1lhAhiTQ==/com.shizhuang.duapp-aLxfQNnnePl3Xieaq6E1uQ==/lib/arm64/libav_media.so
#11 pc 00000000000f0c04 /data/app/~~yvshfyvSUZ46EK1lhAhiTQ==/com.shizhuang.duapp-aLxfQNnnePl3Xieaq6E1uQ==/lib/arm64/libav_media.so
#12 pc 00000000000d7118 /data/app/~~yvshfyvSUZ46EK1lhAhiTQ==/com.shizhuang.duapp-aLxfQNnnePl3Xieaq6E1uQ==/lib/arm64/libav_media.so
#13 pc 00000000000d56e4 /data/app/~~yvshfyvSUZ46EK1lhAhiTQ==/com.shizhuang.duapp-aLxfQNnnePl3Xieaq6E1uQ==/lib/arm64/libav_media.so
#14 pc 00000000000d3360 /data/app/~~yvshfyvSUZ46EK1lhAhiTQ==/com.shizhuang.duapp-aLxfQNnnePl3Xieaq6E1uQ==/lib/arm64/libav_media.so
#15 pc 00000000000d32b4 /data/app/~~yvshfyvSUZ46EK1lhAhiTQ==/com.shizhuang.duapp-aLxfQNnnePl3Xieaq6E1uQ==/lib/arm64/libav_media.so
#16 pc 00000000000d3008 /data/app/~~yvshfyvSUZ46EK1lhAhiTQ==/com.shizhuang.duapp-aLxfQNnnePl3Xieaq6E1uQ==/lib/arm64/libav_media.so
#17 pc 00000000000eb504 /apex/com.android.runtime/lib64/bionic/libc.so (_ZL15__pthread_startPv+64)
#18 pc 000000000008bb0c /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)

```

Abort message是：
```
JNI ERROR (app bug): attempt to use stale Global 0x3a6a (should be 0x3a62)
```
这是一种非常典型的问题，下面的堆栈报在我们自己的libav_media.so中，上面挂在系统里面了，这时候不能轻易断言说挂在系统了，还需要仔细分析一下，很大可能使我们自己的误用导致挂在系统中了。

第一步当然是解栈了，使用上面的介绍的addr2line开始解栈，解出来的堆栈如下：
```
_ZN7_JNIEnv14GetObjectClassEP8_jobject
/Users/jeffli/Library/Android/sdk/ndk/21.1.6352462/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include/jni.h:585

_ZN6effect6OpenGL12ProcessImageEjPKfS2_Pf
/Users/jeffli/poizon/OpenGL/OpenGL/gl/opengl.cc:197

_ZN6effect11FrameBuffer12ProcessImageEjiiPKfS2_Pfl
/Users/jeffli/poizon/OpenGL/OpenGL/gl/frame_buffer.cc:96

_ZN5media11VideoRecord11OnTakePhotoEjii
/Users/jeffli/poizon/androidvideoeditor/library/src/main/cpp/record/video_record.cc:362

_ZN5media11VideoRecord11OnDrawFrameEv
/Users/jeffli/poizon/androidvideoeditor/library/src/main/cpp/record/video_record.cc:454

_ZN5media7Message7ExecuteEv
/Users/jeffli/poizon/androidvideoeditor/library/src/main/cpp/message/message_queue.cc:31

_ZN5media7Handler14ProcessMessageEv
/Users/jeffli/poizon/androidvideoeditor/library/src/main/cpp/message/handler.cc:83

_ZN5media7Handler18MessageQueueThreadEPv
/Users/jeffli/poizon/androidvideoeditor/library/src/main/cpp/message/handler.cc:94

```
我们先查看一下jni.h-->585行是什么？<br>
![jni--->585行代码](./02-files/05.png)<br>
```
    jclass GetObjectClass(jobject obj)
    { return functions->GetObjectClass(this, obj); }

```
这个functions->GetObjectClass会直接调用到libart.so中，我们可以通过这个调用判断出具体在我们自己的代码中什么地方调用的。沿着这个思路分析，发现我们最后调用到jni.h的地方在下面的740行代码中<br>
![调用GetObjectClass代码的地方](./02-files/06.png)<br>
这是音视频SDK中拍照回调的地方，这个take_photo_listener_是一个java层传入的接口对象jobject，正常情况下我们会想到两个点。
> * take_photo_listener_是不是空指针
> * take_photo_listener_存不存在多线程调用

空指针一般不太可能，因为空指针的话和Abort message不太符合，空指针肯定直接就指定了是Null Pointer了，art功能这个强大，这点提醒还是没有问题的。
那就剩下后一种可能性，就是多线程调用。现在验证我们的猜想，take_photo_listener_是什么时候被设置进去的。<br>
![jobject设置的地方](./02-files/07.png)<br>
设置的地方和调用的地方不在一个线程，理论上肯定存在多线程问题的。

但是光这样猜想不行，还是要有理论支撑的。
我们先分析一下这个Crash的源头就不难得到这个结论了。
推荐一个android源码查询的站点cs.android.com，下面分析一下GetObjectClass调用链路。
jni相关的加载代码都在android源码中的art/runtime/jni目录中：<br>
![jni-art代码](./02-files/08.png)<br>
> * art/runtime/jni/jni_internal.cc---> GetObjectClass
> * art/runtime/scoped_thread_state_changeinl.h---> ScopedObjectAccessAlreadyRunnable::Decode
> * art/runtime/thread.cc---> Thread::DecodeJObject
> * art/runtime/jni/java_vm_ext.cc---> JavaVMExt::DecodeGlobal
> * art/runtime/indirect_reference_table.h---> SynchronizedGet
> * art/runtime/indirect_reference_table.h---> IndirectReferenceTable::Get
> * art/runtime/indirect_reference_table.h---> IndirectReferenceTable::CheckEntry

![最终报错的地方](./02-files/09.png)<br>
https://cs.android.com/android/platform/superproject/+/master:art/runtime/indirect_reference_table-inl.h;l=70;drc=master;bpv=1;bpt=1
最终因为什么报错了？是因为在indirectRef表中没有找到当前jobject对应的索引，导致报错了，为什么找不到这个索引，这个jobject还没有被定义为GlobalObject，这就和上面的分析对应起来了，在赋值的时候，因为多线程，还没有执行env->NewGlobalRef(take_photo_listener)代码，导致在索引表中找不到对应的数据。
通过上面的分析来看，只要在global ref做好线程安全的保护即可。

**cpp中怎么保证线程安全：**
> * 使用pthread_mux_lock实现互斥锁，保证同样的代码块或者变量互斥访问，不会出现多线程问题。例如上面的解决方案可以采用这样的处理方式

### 3.6 如何自动化解栈
上面分析了JNI异常的完整分析流程，对于初学音视频开发的同学，解栈是必备的技能，但是包括官方文档在内的技术文章都有一定的门槛，我这边直接放上解栈的工具，帮忙大家一秒钟进入状态。


## 4.Android自带的音视频工具
### 4.1 MediaCodec
### 4.2 MediaExtractor
### 4.3 MediaMuxer
### 4.4 AudioTrack
### 4.5 Camera和Camera2

